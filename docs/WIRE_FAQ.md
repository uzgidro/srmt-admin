# Wire Dependency Injection - FAQ

This project uses [Google Wire](https://github.com/google/wire) for compile-time dependency injection.

## Table of Contents
- [Getting Started](#getting-started)
- [Common Tasks](#common-tasks)
- [Troubleshooting](#troubleshooting)
- [FAQ](#faq)

---

## Getting Started

### What is Wire?

Wire is a compile-time dependency injection framework for Go. Unlike runtime DI frameworks, Wire generates actual Go code at compile time, resulting in:
- Zero runtime overhead
- Compile-time safety
- No reflection
- Easy to debug (generated code is readable)

### Project Structure

```
cmd/
├── main.go          # Application entry point
├── wire.go          # Wire injector definitions (build tag: wireinject)
└── wire_gen.go      # Generated by Wire (build tag: !wireinject, git-ignored)

internal/
└── providers/
    ├── config.go    # Config & logger providers
    ├── storage.go   # Database providers (PostgreSQL, MongoDB, MinIO)
    ├── services.go  # Service providers (Token, ASCUE, Reservoir, HTTP client)
    └── http.go      # HTTP layer providers & AppContainer
```

---

## Common Tasks

### Regenerating Wire Code

After modifying providers or dependencies, regenerate Wire code:

```bash
cd cmd
go run github.com/google/wire/cmd/wire
cd ..
```

Or use the go:generate directive:

```bash
go generate ./cmd
```

### Building the Application

**Option 1: Build the entire cmd package**
```bash
go build -o srmt-admin.exe ./cmd
```

**Option 2: Build with explicit files (not recommended)**
```bash
go build -o srmt-admin.exe ./cmd/main.go ./cmd/wire_gen.go
```

**Option 3: Use go:generate then build**
```bash
go generate ./cmd && go build -o srmt-admin.exe ./cmd
```

### Running in Development

```bash
go run ./cmd
```

### Adding a New Dependency

**Example: Adding a Redis client**

1. **Create a provider function** in `internal/providers/storage.go`:

```go
func ProvideRedisClient(cfg config.Redis, log *slog.Logger) (*redis.Client, func(), error) {
    client := redis.NewClient(&redis.Options{
        Addr:     cfg.Address,
        Password: cfg.Password,
        DB:       cfg.DB,
    })

    // Test connection
    if err := client.Ping(context.Background()).Err(); err != nil {
        return nil, nil, err
    }

    cleanup := func() {
        if err := client.Close(); err != nil {
            log.Error("failed to close redis connection", "error", err)
        }
    }

    return client, cleanup, nil
}
```

2. **Add to ProviderSet** in `internal/providers/storage.go`:

```go
var StorageProviderSet = wire.NewSet(
    ProvidePostgresDriver,
    ProvidePostgresRepo,
    ProvideMongoClient,
    ProvideMongoRepo,
    ProvideMinioRepo,
    ProvideRedisClient, // Add this
)
```

3. **Add to AppContainer** in `internal/providers/http.go`:

```go
type AppContainer struct {
    Router           *chi.Mux
    Server           *http.Server
    Logger           *slog.Logger
    Config           *config.Config
    PgRepo           *pgRepo.Repo
    MongoRepo        *mngRepo.Repo
    MinioRepo        *minio.Repo
    RedisClient      *redis.Client // Add this
    // ... rest of fields
}
```

4. **Update ProvideAppContainer** to accept the new dependency:

```go
func ProvideAppContainer(
    r *chi.Mux,
    srv *http.Server,
    // ... existing params
    redisClient *redis.Client, // Add this
) *AppContainer {
    return &AppContainer{
        // ... existing fields
        RedisClient: redisClient, // Add this
    }
}
```

5. **Regenerate Wire code**:

```bash
cd cmd && go run github.com/google/wire/cmd/wire && cd ..
```

6. **Use in handlers**: Update `router.AppDependencies` if needed, or access via `app.RedisClient` in main.

---

## Troubleshooting

### Error: "undefined: InitializeApp"

**Problem:** GoLand/IDE is building only `main.go` instead of the entire package.

**Solution:**
1. Go to **Run** → **Edit Configurations**
2. Change **Run kind** to "Directory" or "Package"
3. Set **Package path** to `srmt-admin/cmd` or **Directory** to `D:\projects\go\srmt-prime\cmd`

**Or** build from command line:
```bash
go build -o srmt-admin.exe ./cmd
```

### Error: "wire: generate failed"

**Problem:** Wire detected an error in provider definitions.

**Solution:**
1. Read the error message carefully (Wire errors are descriptive)
2. Common issues:
   - Missing provider for a dependency
   - Circular dependency
   - Type mismatch
   - Missing cleanup function signature

**Example error:**
```
wire: no provider found for *redis.Client (required by *providers.AppContainer)
```
**Fix:** Add `ProvideRedisClient` to a ProviderSet.

### Error: "unused variable" in wire_gen.go

**Problem:** Wire generated code that's not being used.

**Solution:** This is usually fine. The generated code might have intermediate variables for clarity. If it's blocking builds, regenerate:
```bash
cd cmd && go run github.com/google/wire/cmd/wire && cd ..
```

### Provider Not Being Called

**Problem:** Added a provider but it's not being called.

**Checklist:**
- [ ] Provider added to a `ProviderSet`?
- [ ] `ProviderSet` added to `wire.Build()` in `cmd/wire.go`?
- [ ] Wire regenerated after changes?
- [ ] Dependency actually used somewhere (in AppContainer or another provider)?

### Cleanup Functions Not Working

**Problem:** Database connections not closing properly.

**Solution:** Ensure provider returns `(Type, func(), error)`:

```go
func ProvidePostgresDriver(cfg *config.Config, log *slog.Logger) (*storage.Driver, func(), error) {
    driver, err := postgres.New(cfg.StoragePath, cfg.MigrationsPath)
    if err != nil {
        return nil, nil, err // Return nil cleanup too
    }

    cleanup := func() {
        driver.DB.Close()
    }

    return driver, cleanup, nil // Return all three
}
```

Wire automatically chains cleanup functions and calls them via `defer cleanup()` in main.

---

## FAQ

### Q: Why use Wire instead of manual DI?

**A:**
- **Before Wire:** `router.SetupRoutes()` had 9 parameters, main.go had 100+ lines of manual wiring
- **After Wire:** Clean providers, 1 parameter to router, compile-time safety
- **Benefits:** Better testability, easier refactoring, no parameter explosion

### Q: When should I regenerate Wire code?

**A:** Regenerate Wire code whenever you:
- Add a new provider
- Modify a provider signature
- Add/remove a ProviderSet
- Change dependencies in AppContainer
- Get "undefined" or "type mismatch" errors

### Q: Can I use Wire for tests?

**A:** Yes! Create test-specific providers:

```go
// internal/providers/testing.go
var TestProviderSet = wire.NewSet(
    ProvideTestConfig,
    ProvideTestLogger,
    ProvideTestPostgresDriver, // In-memory SQLite
)

// cmd/wire_test.go
//go:build wireinject

func InitializeTestApp() (*providers.AppContainer, func(), error) {
    wire.Build(
        providers.TestProviderSet,
        // ... other test sets
    )
    return nil, nil, nil
}
```

### Q: How do I handle optional dependencies?

**A:** Return `nil` from provider if dependency is optional:

```go
func ProvideASCUEFetcher(cfg *config.ASCUEConfig, log *slog.Logger) *ascue.Fetcher {
    if cfg == nil {
        return nil // Wire allows nil
    }
    return ascue.NewFetcher(cfg, log)
}
```

Wire will inject `nil` where the dependency is used. Make sure consuming code handles nil:

```go
if deps.ASCUEFetcher != nil {
    // Use fetcher
}
```

### Q: What's the difference between wire.go and wire_gen.go?

**A:**
- **wire.go**: Your code. Contains injector definitions with build tag `//go:build wireinject`. Not included in normal builds.
- **wire_gen.go**: Generated by Wire. Contains actual implementation with build tag `//go:build !wireinject`. Used in builds. Git-ignored.

### Q: Can I manually edit wire_gen.go?

**A:** **No!** It will be overwritten when Wire regenerates. All changes should go in:
- Provider functions (`internal/providers/*.go`)
- Injector definitions (`cmd/wire.go`)

### Q: How do I debug Wire generation issues?

**A:**
1. Run wire with verbose output:
```bash
cd cmd && go run github.com/google/wire/cmd/wire -v
```

2. Check for circular dependencies:
```bash
cd cmd && go run github.com/google/wire/cmd/wire 2>&1 | grep -i cycle
```

3. Read the generated `wire_gen.go` to see what Wire produced

### Q: What if I need to pass runtime parameters?

**A:** Wire is for build-time DI. For runtime parameters:

**Bad:**
```go
func ProvideUserService(userID string) *UserService // userID is runtime!
```

**Good:**
```go
func ProvideUserService(db *sql.DB) *UserService {
    return &UserService{db: db}
}

// In handler:
func HandleUser(w http.ResponseWriter, r *http.Request) {
    userID := chi.URLParam(r, "id")
    user := userService.GetUser(userID) // Pass runtime param to method
}
```

### Q: How do I organize providers?

**A:** Follow single responsibility:
- **config.go**: Configuration loading, logger, config extraction
- **storage.go**: Database drivers, repositories, storage clients
- **services.go**: Business services, external API clients
- **http.go**: HTTP server, router, middleware
- **testing.go**: Test doubles and mocks

### Q: Can Wire inject interfaces?

**A:** Wire works with **concrete types**. Return concrete types from providers, even if consumers use interfaces:

```go
// Provider returns concrete type
func ProvideUserRepo(db *sql.DB) *pgRepo.UserRepo {
    return &pgRepo.UserRepo{DB: db}
}

// Handler uses interface
type UserGetter interface {
    GetUser(id int) (*User, error)
}

func NewHandler(getter UserGetter) http.HandlerFunc {
    // *pgRepo.UserRepo implements UserGetter interface
}
```

Wire will inject the concrete type, and Go's implicit interface satisfaction does the rest.

### Q: What happens if Wire generation fails in CI/CD?

**A:** Add Wire generation to your CI pipeline:

```yaml
# .github/workflows/build.yml
- name: Generate Wire code
  run: |
    cd cmd
    go run github.com/google/wire/cmd/wire
    cd ..

- name: Build
  run: go build -o srmt-admin ./cmd
```

Or commit `wire_gen.go` (not recommended as it can cause merge conflicts).

### Q: How do I see what Wire generated?

**A:** Read `cmd/wire_gen.go` - it's plain, readable Go code:

```go
func InitializeApp() (*providers.AppContainer, func(), error) {
    config := providers.ProvideConfig()
    logger := providers.ProvideLogger(config)
    token, err := providers.ProvideTokenService(jwtConfig)
    if err != nil {
        return nil, nil, err
    }
    // ... clearly shows dependency order
}
```

### Q: Can I use multiple ProviderSets?

**A:** Yes! Organize related providers into sets:

```go
// cmd/wire.go
wire.Build(
    providers.ConfigProviderSet,    // Config, logger
    providers.StorageProviderSet,   // Databases
    providers.ServiceProviderSet,   // Services
    providers.HTTPProviderSet,      // HTTP layer
)
```

This keeps providers organized and allows selective testing.

---

## Best Practices

1. **Keep providers simple**: One responsibility per provider function
2. **Use cleanup functions**: Always return cleanup for resources that need it
3. **Regenerate often**: Run `wire` after any provider change
4. **Read generated code**: `wire_gen.go` helps understand dependency order
5. **Version control**: Keep `wire.go`, ignore `wire_gen.go`
6. **Document complex providers**: Add comments explaining non-obvious dependencies
7. **Test providers**: Providers are just functions - unit test them
8. **Avoid runtime params**: Use providers for build-time DI, methods for runtime params

---

## Resources

- [Wire GitHub](https://github.com/google/wire)
- [Wire User Guide](https://github.com/google/wire/blob/main/docs/guide.md)
- [Wire Best Practices](https://github.com/google/wire/blob/main/docs/best-practices.md)
- Project Plan: `C:\Users\user\.claude\plans\nested-stirring-boot.md`

---

## Quick Reference

```bash
# Regenerate Wire code
cd cmd && go run github.com/google/wire/cmd/wire && cd ..

# Build application
go build -o srmt-admin.exe ./cmd

# Run application
./srmt-admin.exe

# Run with go run
go run ./cmd

# Generate and build in one command
cd cmd && go run github.com/google/wire/cmd/wire && cd .. && go build -o srmt-admin.exe ./cmd
```
